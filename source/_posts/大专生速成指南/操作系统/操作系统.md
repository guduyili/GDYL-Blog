---
title: 操作系统速成
date: 2025-3-21
categories: 
- 操作系统
tag:
- 带砖生的速成

---

<!-- toc -->

[TOC]

## 操作系统的特征

### **最基本的特征**，互为存在条件：并发，共享

- **并行**：指两个或多个事件可以在**同一时刻**发生，**多核CPU可以实现并行**，一个CPU同一时刻只有一个程序在运行

- **并发**：两个或多个事件可以在**同一时间间隔**发生，用户看起来是每个程序都在运行，实际上是**每个程序都交替执行**

  ![image-20210830104953215](https://i-blog.csdnimg.cn/blog_migrate/feaf848afdd6d8dcc6d93ae8d4eb0773.png)

## 进程管理



**进程控制块（PCB）**：用于描述和控制进程运行的通用数据结构，记录进程当前状态和控制进程运行的全部信息，**是进程存在的唯一标识**

### **进程（Process）与线程（Thread）：**

- **线程**：操作系统进行**"运行调度的最小单位"**

- **进程**：系统进行**"资源分配和调度的基本单位"**

**区别与联系：**

1. 一个进程可以有一个或多个线程
2. 线程包含在进程中，是进程中实际运行工作的单位
3. 进程的线程共享进程资源
4. 一个进程可以并发多个线程，每个线程执行不同的任务

### **五状态模型**

- **就绪状态：**其他资源（进程控制块，内存，栈空间，堆空间）都准备好，只差CPU状态

- **执行状态：**进程获得CPU，其程序正在执行

- **阻塞状态：**进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置

- **创建状态：**创建进程时拥有PCB但其它资源尚未准备就绪

- **终止状态：**进程结束由系统清理或者归还PCB的状态

  ![image-20210830134139425](https://s2.loli.net/2025/03/27/vAwKJLImseuFQZ3.png)

### **进程同步的方法（重要）**

![image-20210826215825209](https://s2.loli.net/2025/03/27/7Tqefo5haAFsrDm.png)

1.**使用fork系统调用创建进程：**使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。

- fork系统调用的是用于创建进程的；
- fork创建的进程初始化状态与父进程一样；
- 系统会为fork的进程分配新的资源

2.**共享内存：**在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程内的内存空间是独立的，因此进程默认是不能访问进程空间意外的内存空间的。

- 共享存储**允许不相关的进程**访问同一片物理内存；
- 共享内存是两个进程之间**共享和传递数据最快的方式**；
- 共享内存**未提供同步机制**，需要借助其他机制管理访问；

![image-20210826223244411](https://s2.loli.net/2025/03/27/QeS4gqTP9MURsuJ.png)

3.**Unix域套接字**

域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。

**套接字（socket）**：为网络通信中使用的术语

Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx，uWSGI等。

服务端和客户端分别使用Unix域套接字的过程：

![image-20210826223709480](https://s2.loli.net/2025/03/27/yuVb6H9NJ3SY51R.png)

### **线程同步的方法（重要）**

**线程同步的方法：**

1. **互斥锁：**互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：**解锁和加锁**，两个状态可以**保证资源访问的串行**。原子性：指一系列操作**不可被中断**的特性，要么全部执行完成，要么全部没有执行。

![image-20210826220013572](https://s2.loli.net/2025/03/27/zEbUDMGqTQeL4av.png)

   2.**自旋锁**：自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种**忙等待状态**，**即死循环等待锁被释放，自旋锁的效率远高于互斥锁**。特点：**避免了进程或者线程上下文切换的开销**，但是**不适合在单核CPU使用**

​	3.**读写锁：**是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即`对多读少写的操作效率提升`很显著

​	4.**条件变量**：是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，**当满足条件时候，可以给先线程信号通知唤醒**

### 线程同步方法对比（重要）

![image-20210826222325975](https://s2.loli.net/2025/03/27/VShR8t4AvgToJpW.png)

![image-20210826222346498](https://s2.loli.net/2025/03/27/7iwsvre5c9SRP6m.png)

|              |                                                              |
| :----------: | ------------------------------------------------------------ |
|   同步方法   | 描述                                                         |
|  **互斥锁**  | **最简单**的一种线程同步方法，会**阻塞线程**                 |
|  **自旋锁**  | **避免切换**的一种线程同步方法，属于**”忙等待“**             |
|  **读写锁**  | 为**”读多写少“**的资源设计的线程同步方法，可以**显著提高性能** |
| **条件变量** | 相对复杂的一种该线程同步方法，有更灵活的使用场景             |

### 进程的标记

|          |                                                             |
| :------: | :---------------------------------------------------------: |
| 状态符号 |                          状态说明                           |
|    R     |             （TASK_RUNNING）,进程正处于运行状态             |
|    S     |          （TASK_INTERRUPTIBLE）,进程正处于睡眠状态          |
|    D     |     （TASK_UNINTERRUPTIBLE）,进程正处于IO等待的睡眠状态     |
|    T     |             （TASK_STOPPED）,进程正处于暂停状态             |
|    Z     | （TASK_DEAD or EXIT_ZOMBIE）,进程正处于退出状态，或僵尸进程 |

## 作业管理

### 进程调度

**作业管理值进程调度**

- 定义：指计算机通过决策决定哪个就绪进程就可以**获得CPU使用权**

**进程调度方式：**

**非抢占式调度：**只能由当前运行的进程**主动放弃CPU**；

- 处理器一旦分配给某个进程，就让该进程一直使用下去；
- 调度程序不以任何原因抢占正在被使用的处理器；

**抢占式调度**：可由**操作系统剥夺当前进程的CPU使用权**。

- 允许调度程序以一定的策略暂停当前运行的进程；
- 保存好旧进程的上下文信息，分配处理器给新进程；

![img](https://s2.loli.net/2025/04/02/kLBv3ubNJEflcIp.png)

### 进程调度的三大机制

- 就绪队列的排队机制：为了提高进程调度的效率，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程

![image-20210830141937877](https://s2.loli.net/2025/04/02/pCGtrn89S4Q21PN.png)

- **选择运行进程的委派机制：**调度程序以一定的策略，选择就绪进程，将CPU资源分配给它

- **新老进程的上下文切换机制：**保存当前进程的上下文信息，装入被委派执行进程的运行上下文。

  ![image-20210830141949702](https://s2.loli.net/2025/04/02/jfxVhqUO7kZM1H6.png)

**进程调度算法**：

1. **先来先服务算法：**按照在**就绪队列中的先手顺序**执行
2. **短进程优先调度算法：**优先选择就绪队列中估计**运行时间最短的进程**，不利于长作业进程的执行
3. **高优先权优先调度算法：**进程附带优先权，**优先选择权重高的进程**，可以使得紧迫的任务优先处理
4. **时间片轮转调度算法：**按照FIFO的原则排列就绪进程，每次从队列头部去除待执行进程，**分配一个时间片执行**，是相对公平的调度算法，但是不能保证就是响应用户

### 饥饿：

由于长期得不到资源导致进程无法推进

### 死循环：

代码逻辑BUG

### 死锁：

**两个或两个以上的进程**在执行过程中，**由于竞争资源**或者**由于彼此通信**二造成的一种**阻塞**的现象，若无外力作用，它们都将无法推进下去，永远在相互等待的进程称为死锁进程

**死锁的产生：**竞争资源（共享资源数量不满足各进程需求），进程调度顺序不当，当调度顺序为A->B->C->D时会产生死锁，但改为A->D->B->C则不会产生。

![200bad6d5f317b1d2ab223272d66e6ed](https://s2.loli.net/2025/03/30/j4Pg9WQ5s2KUneq.png)

**`死锁的四个必要条件`**

1. **互斥条件：必须互斥使用资源才会产生死锁**
2. **请求保持条件：进程至少保持一个资源**，又提出新的资源请求，新资源被占用，**请求被阻塞**，被阻塞的进程不释放自己保持的资源
3. **不可剥夺条件：**进程获得的资源在未完成使用前不能被剥夺（包括OS），**只能由进程自身释放**
4. **环路等待条件：**发生死锁时，必然存在进程-资源环形链，环路等待不一定造成死锁，但死锁一定有环路等待

**`死锁的处理策略`**

一.**预防死锁的方法**：破坏四个必要条件的中一个或多个。

1. **破坏互斥条件**：将**临界资源改造成共享资源**（Spooling池化技术）；（可行性不高，很多时候无法破坏互斥条件）
2. **破坏请求保持条件**：系统规定进程运行之前，**一次性申请所有需要的资源**；（资源利用率低，可能导致别的线程饥饿）
3. **破坏不可剥夺条件**：当一个进程请求新的资源得不到满足时，必须**释放占有的资源**；（实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放造成额外的系统开销）
4. **破坏环路等待条件**：可用**资源线性排序**，申请必须按照需要递增申请；（进程实际使用资源顺序和编号顺序不同，会导致资源浪费）

二.**银行家算法**：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；

三.**死锁的检测和解除**：死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法

## 四种调度算法

- 先来先服务（FCFS）
- 短作业优先（SJF）
- 优先级调度算法（PS Priority Scheduling）
- 时间片轮转调度算法（RR Round Robin）

周转时间 = 完成时间 - 到达时间

带权周转时间 = 周转时间/运行时间

等待时间 = 周转时间 - 运行时间

## 文件管理

### 文件的逻辑结构

- **逻辑结构的文件类型**：有结构文件（文本文件，文档，媒体文件），无结构文件（二进制文件，链接库）
- **顺序文件**：按顺序放在存储介质中的文件，在逻辑文件当中**存储效率最高**，但不适合存储可变长文件
- **索引文件**：为解决可变长文件存储而方面，需要配合索引表存储

### 辅存的存储空间分配

- **辅存的分配方式**：连续分配（读取文件容易，速度快），链接分配（隐式链接和显示链接），索引分配
- **辅存的存储空间管理**：空闲表，空闲链表，位示图。

**目录树**：使得任何文件或目录都有唯一的路径

![4b48b5c2dd2080a4b67835fc47606a2e](https://s2.loli.net/2025/03/31/U8wHpFhZbM2mxqD.jpg)



![70a836ff238585b4003c73ca02e712e0](https://s2.loli.net/2025/03/31/FJSO6uh1UtmdijV.jpg)

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| **目录** | **描述**                                                     |
| /bin     | 存放二进制可执行文件（ls,cat,mkdir等），常用命令一般都在这里 |
| /etc     | 存放系统管理和配置文件                                       |
| /home    | 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user |
| /usr     | 用于存放系统应用程序，比较重要的目录/usr/local本地管理员软件安装目录 |
| /opt     | 额外安装的可选应用程序包所放置的位置                         |
| /proc    | 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息 |
| /root    | 超级用户（系统管理员）的主目录                               |
| /sbin    | 存放二进制可执行文件，只有root才能访问                       |
| /dev     | 用于存放设备文件                                             |
| /mnt     | 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统 |
| /boot    | 存放用于系统引导时使用的各种文件                             |
| /lib     | 存放跟文件提供中的程序运行所需要的共享库及内核模块           |
| /var     | 用于存放运行时需要改变数据的文件                             |

![ce0b12633a40cfb6c4e0766a855f66a5](https://s2.loli.net/2025/03/31/Wgt795CHlMDrqUG.jpg)

## 设备管理

I/O设备的基本概念：将数据输入输出计算机的外部设备

![lqx](../img/36590efb66564f6081ec1eb74276ff0b.png)

![image-20250512142529258](./../../../img/image-20250512142529258.png)
