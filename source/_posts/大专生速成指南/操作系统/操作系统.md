---
title: 操作系统速成
date: 2025-3-21
updated: 2025-3-24
categories: 
- 操作系统
tag:
- 带砖生的速成

---

<!-- toc -->

[TOC]

## 操作系统的特征

### **最基本的特征**，互为存在条件：并发，共享

- **并行**：指两个或多个事件可以在**同一时刻**发生，**多核CPU可以实现并行**，一个CPU同一时刻只有一个程序在运行

- **并发**：两个或多个事件可以在**同一时间间隔**发生，用户看起来是每个程序都在运行，实际上是**每个程序都交替执行**

  ![image-20210830104953215](https://i-blog.csdnimg.cn/blog_migrate/feaf848afdd6d8dcc6d93ae8d4eb0773.png)

## 进程管理



**进程控制块（PCB）**：用于描述和控制进程运行的通用数据结构，记录进程当前状态和控制进程运行的全部信息，**是进程存在的唯一标识**

### **进程（Process）与线程（Thread）：**

- **线程**：操作系统进行**"运行调度的最小单位"**

- **进程**：系统进行**"资源分配和调度的基本单位"**

**区别与联系：**

1. 一个进程可以有一个或多个线程
2. 线程包含在进程中，是进程中实际运行工作的单位
3. 进程的线程共享进程资源
4. 一个进程可以并发多个线程，每个线程执行不同的任务

### **五状态模型**

- **就绪状态：**其他资源（进程控制块，内存，栈空间，堆空间）都准备好，纸擦和CPU状态

- **执行状态：**进程获得CPU，其程序正在执行

- **阻塞状态：**进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置

- **创建状态：**创建进程时拥有PCB但其它资源尚未准备就绪

- **终止状态：**进程结束由系统清理或者归还PCB的状态

  ![image-20210830134139425](https://s2.loli.net/2025/03/27/vAwKJLImseuFQZ3.png)

### **进程同步的方法（重要）**

![image-20210826215825209](https://s2.loli.net/2025/03/27/7Tqefo5haAFsrDm.png)

1.**使用fork系统调用创建进程：**使用fork系统调用无参数，fork会返回两次，分别返回子进程id和0，返回子进程id的是父进程，返回0的是子进程。

- fork系统调用的是用于创建进程的；
- fork创建的进程初始化状态与父进程一样；
- 系统会为fork的进程分配新的资源

2.**共享内存：**在某种程度上，多进程是共同使用物理内存的，但是由于操作系统的进程管理，进程内的内存空间是独立的，因此进程默认是不能访问进程空间意外的内存空间的。

- 共享存储**允许不相关的进程**访问同一片物理内存；
- 共享内存是两个进程之间**共享和传递数据最快的方式**；
- 共享内存**未提供同步机制**，需要借助其他机制管理访问；

![image-20210826223244411](https://s2.loli.net/2025/03/27/QeS4gqTP9MURsuJ.png)

3.**Unix域套接字**

域套接字是一种高级的进程间通信的方法，可以用于同一机器进程间通信。

**套接字（socket）**：为网络通信中使用的术语

Unix系统提供的域套接字提供了网络套接字类似的功能，如Nfinx，uWSGI等。

服务端和客户端分别使用Unix域套接字的过程：

![image-20210826223709480](https://s2.loli.net/2025/03/27/yuVb6H9NJ3SY51R.png)

### **线程同步的方法（重要）**

**线程同步的方法：**

1. **互斥锁：**互斥锁是最简单的线程同步的方法，也称为互斥量，处于两态之一的变量：**解锁和加锁**，两个状态可以**保证资源访问的串行**。原子性：指一系列操作**不可被中断**的特性，要么全部执行完成，要么全部没有执行。

![image-20210826220013572](https://s2.loli.net/2025/03/27/zEbUDMGqTQeL4av.png)

   2.**自旋锁**：自旋锁是一种多线程同步的变量，使用自旋锁的线程会反复检查锁变量是否可用，自旋锁不会让出CPU，是一种**忙等待状态**，**即死循环等待锁被释放，自旋锁的效率远高于互斥锁**。特点：**避免了进程或者线程上下文切换的开销**，但是**不适合在单核CPU使用**

​	3.**读写锁：**是一种特殊的自旋锁，允许多个读操作同时访问资源以提高读性能，但是对写操作是互斥的，即**`对多读少写的操作效率提升`**很显著

​	4**.条件变量**：是一种相对比较复杂的线程同步方法，条件变量允许线程睡眠，直到满足某种条件，**当满足条件时候，可以给先线程信号通知唤醒**

### 线程同步方法对比（重要）

![image-20210826222325975](https://s2.loli.net/2025/03/27/VShR8t4AvgToJpW.png)

![image-20210826222346498](https://s2.loli.net/2025/03/27/7iwsvre5c9SRP6m.png)

|              |                                                              |
| :----------: | ------------------------------------------------------------ |
|   同步方法   | 描述                                                         |
|  **互斥锁**  | **最简单**的一种线程同步方法，会**阻塞线程**                 |
|  **自旋锁**  | **避免切换**的一种线程同步方法，属于**”忙等待“**             |
|  **读写锁**  | 为**”读多写少“**的资源设计的线程同步方法，可以**显著提高性能** |
| **条件变量** | 相对复杂的一种该线程同步方法，有更灵活的使用场景             |

### 进程的标记

|          |                                                             |
| :------: | :---------------------------------------------------------: |
| 状态符号 |                          状态说明                           |
|    R     |             （TASK_RUNNING）,进程正处于运行状态             |
|    S     |          （TASK_INTERRUPTIBLE）,进程正处于睡眠状态          |
|    D     |     （TASK_UNINTERRUPTIBLE）,进程正处于IO等待的睡眠状态     |
|    T     |             （TASK_STOPPED）,进程正处于暂停状态             |
|    Z     | （TASK_DEAD or EXIT_ZOMBIE）,进程正处于退出状态，或僵尸进程 |

## 作业管理

### 饥饿：

由于长期得不到资源导致进程无法推进

### 死循环：

代码逻辑BUG

### 死锁：

**两个或两个以上的进程**在执行过程中，**由于竞争资源**或者**由于彼此通信**二造成的一种**阻塞**的现象，若无外力作用，它们都将无法推进下去，永远在相互等待的进程称为死锁进程

**死锁的产生：**竞争资源（共享资源数量不满足各进程需求），进程调度顺序不当，当调度顺序为A->B->C->D时会产生死锁，但改为A->D->B->C则不会产生。

img

**`死锁的四个必要条件`**

1. **互斥条件：必须互斥使用资源才会产生死锁**
2. **请求保持条件：进程至少保持一个资源**，又提出新的资源请求，新资源被占用，**请求被阻塞**，被阻塞的进程不释放自己保持的资源
3. **不可剥夺条件：**进程获得的资源在未完成使用前不能被剥夺（包括OS），**只能由进程自身释放**
4. **环路等待条件：**发生死锁时，必然存在进程-资源环形链，环路等待不一定造成死锁，但死锁一定有环路等待

**`死锁的处理策略`**

一.**预防死锁的方法**：破坏四个必要条件的中一个或多个。

1. **破坏互斥条件**：将**临界资源改造成共享资源**（Spooling池化技术）；（可行性不高，很多时候无法破坏互斥条件）
2. **破坏请求保持条件**：系统规定进程运行之前，**一次性申请所有需要的资源**；（资源利用率低，可能导致别的线程饥饿）
3. **破坏不可剥夺条件**：当一个进程请求新的资源得不到满足时，必须**释放占有的资源**；（实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放造成额外的系统开销）
4. **破坏环路等待条件**：可用**资源线性排序**，申请必须按照需要递增申请；（进程实际使用资源顺序和编号顺序不同，会导致资源浪费）

二.**银行家算法**：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；

三.**死锁的检测和解除**：死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法
